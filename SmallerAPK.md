# SmallerAPK

## Part 1: Anatomy of an APK

If I ask a bunch of developers what their app’s size is, I’m pretty sure most will look at the APK file generated by Android Studio and tell me how much disk space it takes up on their computer. It’s the most straightforward answer and it’s technically correct, but perhaps I should be asking better questions. Consider these for example:

- How much space does your app take up when installed on a user’s device?

- How much network data does the user have to pay for to download and install your app?

- How big is the download size for an update to your app for existing users?

- What is the memory footprint (in terms of RAM used) of running your application?

If you’re a developer with a high end phone on an all-you-can-eat data plan you might be wondering if it’s worth spending your time on optimizing for APK size… Remember, not all devices have the same storage, memory or network connectivity.

There are places in the world where users have to pay for every megabyte of data they download and Wi-Fi hotspots are not readily available on every corner.

Some devices don’t have the internal storage capacity (disk space) to let users install all the applications they need, which means they have to think twice before installing or updating any software. And who knows, these might be your next thousands or million users, so let’s try to make that APK smaller! It will benefit everyone.

Of course, considering the various requirements and constraints we all have to work with, it’s difficult to choose a one-size-fits-all solution. Sometimes, sacrificing initial download size will speed up subsequent updates. In other cases, contrary to intuition, keeping files uncompressed in your APK can reduce the final amount of disk space taken on the device. I will try to highlight these trade-offs and provide an explanation wherever applicable, but ultimately it’s up to you, the developer, to choose a mix of techniques that make sense for your app and your users.

Runtime memory footprint is mostly out of scope for this series of articles. The presented optimizations may have some small side effects for memory usage and performance, both positive and negative. I’ll try to mention any clear downsides when applicable, but it’s left to the reader to measure performance characteristics of your app and make the final call. Remember, #perfmatters!

### What’s in an APK
Before I begin talking about how to slim down an app, let’s first look at the file format itself. An APK is really just a ZIP archive, containing files that make up your application. Normally in the APK you will find entries such as:

#### classes.dex
Contains compiled application code, transformed into Dex bytecode. You might see more than one DEX file in your APK if you are using multidex to overcome the 65536 method limit. Beginning with Android 5.0 which introduced the ART runtime, these are compiled into OAT files by the ahead-of-time compiler at install time and put on the device’s data partition.

#### res/
This folder contains most XML resources (e.g. layouts) and drawables (e.g. PNG, JPEG) in folders with various qualifiers, like -mdpi and -hdpi for densities, -sw600dp or -large for screen sizes and -en, -de, -pl for languages. Please note that any XML files in res/ have been transformed into a more compact, binary representation at compile time, so you won’t be able to open them with a text editor from inside the APK.

#### resources.arsc
Some resources and identifiers are compiled and flattened into this file. It’s normally stored in the APK without compression for faster access during runtime. Compressing this file manually might seem like an easy win, but is actually not a good idea for at least two reasons. One, Play Store compresses any data for transfer anyway and two, having the file compressed inside the APK would waste system resources (RAM) and performance (especially app startup time).

#### AndroidManifest.xml
Similar to other XML resources, your application Manifest is transformed during compilation into a binary format. Play Store uses certain information contained in the AndroidManifest to decide if an APK can be installed on a device, checking against allowed densities or screen sizes and available hardware and features (such as a touchscreen). If you want to inspect those Manifest entries after compilation, you can use the aapt tool from the Android SDK:		

		$ aapt dump badging your_app.apk

#### libs/
Any native libraries (*.so files) will be put in subfolders named after the ABI (CPU architecture, e.g. x86, x86_64, armeabi-v7a) that they’re targeting under the libs/ folder. Normally, they are copied out of the APK into your /data partition at install time. However, since the APK itself is never altered while it sits on a user’s device, this essentially doubles the space needed for any native library. 

#### assets/
This folder is used for any file assets that will not be used as Android-type resources. Most commonly this will be font files or game data, like levels and textures, as well as any other application data that you want to open directly as a file stream.

#### META-INF/
This folder is present in signed APKs and contains a list of all files in the APK with their signatures. The way signing in Android works currently is that it verifies the signatures against uncompressed file contents from the archive, one by one.

##

This has some interesting consequences. Because every entry in a ZIP file is stored separately, this means that you can change individual files’ compression level without re-signing. The signature verification will fail however if you remove any file from the archive after it is signed.

One more thing to note about how a signed APK is created is that the zipalign tool is used as the last stage of the build. If you change the contents of the archive by hand, normally you will have to re-sign, then zipalign before uploading the APK to the Play Store.

---
## Part 2: Minifying code

 It’s all about keeping your codebase clean, your dependencies in check and giving you the tools to help with those tasks.

### Dex code minification
The first thing you want to do is enable the built-in minifier. It will try to strip any unused classes and class members, as well as rename any identifiers using shorter names. Both operations make the resulting code smaller, but the latter can make debugging cumbersome, so I suggest you only enable minification for your release build type:

build.gradle

		android {
		    ...
		    buildTypes {
		        release {
		            minifyEnabled true
		            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
		        }
		    }
		}

The second line provides configuration files for the minifier in [ProGuard rules](http://proguard.sourceforge.net/manual/usage.html) format. The first configuration file ([Sdk/tools/proguard/proguard-android.txt](https://android.googlesource.com/platform/sdk/+/master/files/proguard-android.txt)) is included with the SDK and contains some sane defaults for every Android project. Looking at those rules can help you get familiar with the Proguard configuration syntax. For example, this keeps (in other words prevents from being removed or renamed) any setter or getter methods from View subclasses:

		# keep setters in Views so that animations can still work.
		# see http://proguard.sourceforge.net/manual/examples.html#beans
		-keepclassmembers public class * extends android.view.View {
		    void set*(***);
		    *** get*();
		}

With any luck, your app will work with the default configuration in place. During the build process, a tool called AAPT also generates the necessary rules for retaining all your Activities and other components that are mentioned in the Manifest, as well as any Views used in XML layouts. Library dependencies should provide their minifier configuration through consumer ProGuard files, though sometimes they only provide the necessary ProGuard rules on their website or manual. In that case, you will be required to copy them to your app/proguard-rules.pro file.

It will often be the case, unfortunately, that after enabling minification your app will either not compile or break during runtime, usually by throwing ClassNotFoundException for classes removed by the minifier. To fix this, you will need to create a proguard-rules.pro file in your app/ folder and provide rules needed to get rid of compile-time warnings (watch the message log for info). You also have to make sure that you keep any classes and members that are used during runtime, but are getting stripped by the minifier. These are usually parts of your code that are accessed through reflection.

One specific case is when custom attributes in XML layouts take a class name as a String, like setting a RecyclerView’s layoutManager for example:

		<android.support.v7.widget.RecyclerView
		    app:layoutManager=”android.support.v7.widget.GridLayoutManager”
		    ...
		/>

In this case, AAPT will not be able to figure out the class usage and generate the necessary ProGuard rule. To apply a fix, you should put the following line in your ProGuard configuration to keep the GridLayoutManager class and any of its public and protected methods from being removed or renamed:

		-keep public class android.support.v7.widget.GridLayoutManager {
		    public protected *;
		}
To check if the configuration rules you write are having the desired effect, you can inspect the classes.dex files in the resulting APK with a tool like ClassyShark. It’s also important that you test your app thoroughly! The fact that the app opens without crashing is not an indication of a correct minifier config. You must test every screen and user flow in your app for crashes. (may I suggest checking out the [Android Testing Support Library and Espresso](https://google.github.io/android-testing-support-library/) for that? :)

#### Uploading ProGuard mappings to Play
Analysing exceptions thrown by obfuscated code running on your users’ devices used to be a bit inconvenient until recently. Normally you’d have to copy the stacktrace from Play Developer Console and use a tool on your computer together with a ProGuard mappings file generated at compile time to decode the original class and methods names.

Play Developer Console now has the option to [upload the mappings](https://support.google.com/googleplay/android-developer/answer/6295281) file together with your APK and will show deobfuscated stacktraces right there in the Crashes and ANRs panel. Remember, the mapping file you use has to be from the exact same compilation run as your release APK.

**Note:** you will find the mappings.txt file in your project folder under this path: <module>/build/outputs/mapping/mapping.txt

#### ProGuard configuration for libraries
If you’re building an AAR library to be used in other projects that needs ProGuard rules to work, you should use the consumerProguardFiles option to package a ProGuard configuration file with the AAR. This way, anyone using your library will not have to worry about adding rules manually when enabling the minifier. Also make sure to provide information on any other requirements when compiling a project with your library in the manual.

build.gradle

		android {
		    ...
		    defaultConfig {
		        consumerProguardFiles “proguard-rules.txt”
		    }
		}

#### Using granular dependencies for Google Play Services
When using the Google Play Services library in your project, remember to switch to granular dependencies. This means you won’t be pulling in the whole client library if you’re just using a couple of features like Ads, Maps or GCM. There’s a table with all Gradle dependency strings that you can use on [developers.google.com](https://developers.google.com/android/guides/setup). And by the way, ProGuard consumer rules are included with Play services so they should just work if you enable the code minifier for your build.

#### Tracking down dependencies
The great thing about developing for Android is that if you have a problem, there is probably someone who’s already solved it. As your project grows, you will usually pull in more and more external dependencies to speed up development time. The most common ones are probably the Android Support Library for backwards compatibility, Play Services, an image loading library, an HTTP client and various other SDKs…

#### Transitive library dependencies
When you think you’re “just” adding a small helper lib and suddenly your Dex size explodes and your method count goes through the roof, that might be because of transitive dependencies that you don’t normally see in your build.gradle file. Fortunately, there are tools that can help:

		$ ./gradlew app:dependencies
		...
		compile — Classpath for compiling the main sources.
		+ — — com.android.support:appcompat-v7:23.1.1
		| \ — — com.android.support:support-v4:23.1.1
		| \ — — com.android.support:support-annotations:23.1.1
		+ — — com.android.support:cardview-v7:23.1.1
		+ — — com.android.support:design:23.1.1
		| + — — com.android.support:appcompat-v7:23.1.1 (*)
		| + — — com.android.support:recyclerview-v7:23.1.1
		| | + — — com.android.support:support-annotations:23.1.1
		| | \ — — com.android.support:support-v4:23.1.1 (*)
		| \ — — com.android.support:support-v4:23.1.1 (*)
		+ — — com.android.support:recyclerview-v7:23.1.1 (*)
		\ — — com.android.support.test.espresso:espresso-idling-resource:2.2.1

The <modulename>:dependencies command gives you an overview of every library in your project and its dependency tree. An asterisk (*) next to the version number tells you that this particular dependency has been mentioned in the output before and so it would have been included in your project anyway, unless you remove all other instances of it.

**Note:** if you are using product flavors and you only need a library for some variants of your app (for example an Ads SDK only for the free version), you can specify dependencies prefixed with your flavor name, e.g. 
dependencies { freeCompile ‘…’ }.

####Inspecting Dex files with ClassyShark
Sometimes, in order to shield the developer from version clashes, a library includes its dependencies directly within its code but with a changed package name, essentially shadowing the original one. It also means that you won’t see this kind of dependency in the Gradle dependency tree.

If you want to get a better view on the exact classes and package names that are packaged in your APK, you can use [ClassyShark](https://github.com/google/android-classyshark) to inspect your Dex files. It’s also great for testing out your ProGuard rules to see exactly what effect they’re having on the final APK.

**Note:** As a bonus, ClassyShark will show method counts for packages, which might help you identify the biggest multidex offenders.

---
## Part 3: Removing unused resources
There’s two ways you can remove resources that are not used by your app, but get packaged into the APK because they’re in your project folder or dependencies. One method relies on the minifier/shrinker that we discussed in the previous chapter. Apart from removing unused code, it can also analyze which resources are actually being used and strip those that are never included in your layouts, drawables, code, etc. To enable resource shrinking, add this line to your release build type:

build.gradle

		android {
		    ...
		    buildTypes {
		        release {
		            minifyEnabled true
		            shrinkResources tru
		            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
		        }
		    }
		}

Just like with removing code, automatic tools might sometimes make the wrong call about which resources are actually used. You can tell the build system about resources you want to keep with the special tools:keep attribute, similar to how ProGuard configuration files can list classes and methods to keep. You can add it on any <resources> tag that’s already in your project, or create a separate file for the shrinker rules:

res/raw/keep.xml

		<?xml version="1.0" encoding="utf-8"?>
		<resources xmlns:tools="http://schemas.android.com/tools"
		   tools:keep="@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*"
		/>

You can also specify tools:discard to deliberately remove resources that were kept:

res/raw/keep.xml

		<?xml version="1.0" encoding="utf-8"?>
		<resources xmlns:tools="http://schemas.android.com/tools"
		    tools:shrinkMode="safe"
		    tools:discard="@layout/unused2"
		/>

Of course, it’s good practice to keep your project folder tidy and organized anyway, so if there are any old resources that you know will not be used anymore, you should just remove the files.

### Removing unused configurations with ResConfigs
Lots of libraries come with string resources translated into many languages. That’s the case with the Support Library and Google Play Services for example. You might even have translations that you started working on for your app, but you are not ready to release to markets serving those languages just yet. You can use the resConfigs option to restrict the configurations that will be included in the final APK

build.gradle

		android {
		    defaultConfig {
		        ...
		        resConfigs "en", "fr"
		    }
		}

### Sparse configurations in resources.arsc
The problem I’m about to describe in this section usually only hits really large apps, with hundreds or thousands of resource strings, styles or other identifiers that go into the resources.arsc file.

If you notice this file takes up an unusually large amount of space in your APK, this might be an indicator that you have too many sparse configurations. Let me explain on a simple example.
Let’s say you have 5 base strings that are defined in a default configuration folder (values/strings.xml). The strings themselves will be defined in a string pool, while another area of the resources file will contain a resource config consisting of pointers to those strings. For the sake of this explanation, this is how a simplified resources.arsc file might look like:

		String pool: "My App", "Hello", "Exit", "Settings", "Feature"
		                  Default config: 
		string/myapp      0x00000001
		string/hello      0x00000002
		string/exit       0x00000003
		string/settings   0x00000004
		string/feature    0x00000005

Now imagine that you’re adding a new feature to your app that works only on API 21+. The feature needs to show a different message when it’s used, so you decide to override a string in values-v21/strings.xml and recompile your app.

You would think that you’re adding just one new string value to the string pool and one string pointer for the newly created v21 config. Unfortunately, that’s not how the resources.arsc file format works. What you might see instead is:

		String pool: "My App", "Hello", "Exit", "Settings", "Feature", "New feature"
		                  Default config:         -v21 config:
		string/myapp      0x00000001              NO_ENTRY
		string/hello      0x00000002              NO_ENTRY
		string/exit       0x00000003              NO_ENTRY
		string/settings   0x00000004              NO_ENTRY
		string/feature    0x00000005              0x00000006
		                  
		                  ==========              ==========
		Config size:      20 bytes                20 bytes!

As it turns out, each configuration (-v21, -land or even -en-land-v21) reserves space for pointers on every possible resource position. The actual pointers can be null, meaning that there is no value defined in this configuration. 
A null pointer still takes up 4 bytes.

Like I mentioned in the beginning, the possible savings here depend mostly on how many strings (or other types of resources) you have in your app. For our example, the overhead of the -v21 config for strings is just 4 * 4 bytes, that is 16 bytes wasted in null entries (plus 4 bytes for a pointer we actually care about).

However, in a real life scenario, an app that defines 3500 strings and has a separate landscape configuration with 1 string translated into 50 languages (so it has folders such as values-en-land, -pl-land, -de-land, -fr-land…) will lose:
		
		4 bytes * 3500 null entries * 50 languages = 700 kilobytes

That is 700 kilobytes that can be saved just by removing one string, and I’ve seen apps that saved more than 2.5MB for moving as little as 3 resources around to reduce the number of configurations.

There’s one catch — since you put a resource in a separate config in the first place, that usually means you need it there and it’s actually the proper way to do it in Android. But if you can identify that one or several resources that will save you lots of space, you might consider finding a way to get rid of them altogether.

Another way, although less elegant, is to switch between different versions of the resource in code for that one situation. For example, in your values/strings.xml you could have two strings: string/my_feature and string/my_feature_land, then select the correct one at runtime based on current screen orientation.

We’ve open sourced a tool that can help you find sparse resource configurations and identify which resources contribute to your resources.arsc bloat. It’s called ArscBlamer and can be found here:[google/android-arscblamer](https://github.com/google/android-arscblamer)

You will need [Bazel](http://bazel.io/) installed to compile ArscBlamer. You can compile and run using this command (all in one line):

		$ bazel run //java/com/google/devrel/gmscore/tools/apk/arsc:ArscDumper --apk=/FULL_PATH_TO_APK/bar.apk - keys > output.csv

Then, open the resulting CSV file in any editor (like Google Sheets) and sort by the Null entries column in descending order.

The configurations which have the most Null entries are possible candidates for pruning, and the resource names (Keys) on the right will be the ones you can remove to get rid of the configuration.

---
## Part 4: Multi-APK through ABI and density splits is one click away.
Android is a diverse ecosystem, with devices ranging from phones to tablets and even TVs, each having its own hardware characteristics such as screen size, pixel density and CPU architecture.

Although in the [documentation](http://developer.android.com/google/play/publishing/multiple-apks.html) we encourage you to create a single package to support all these devices, sometimes the biggest space savings can come from breaking up your app into multiple APKs. If you prepare your app this way, a user on a phone with an ARM processor will not have to download native code for x86 CPUs or someone with a medium density screen won’t be storing extra-high density assets and wasting space and bandwidth.

You can find details about how Multi-APK support works, what kind of filters are supported on the Play Store and some important rules about version numbering [here](http://developer.android.com/google/play/publishing/multiple-apks.html#HowItWorks). It’s crucial to understand the theory behind Multi-APK, so that you as a developer can decide if you want to add to the complexity of your release process and if it’s something that will benefit your users.

The simplest way to add Multi-APK support to your app is through an Android Studio (or more precisely the Android Gradle plugin) configuration option called [splits](http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits). Splits is a section you can add in your build.gradle file that enables the creation of separate APKs for different screen densities or ABIs (i.e. CPU architectures) as part of the usual build process.

### Density splits
If you need a sample application to play around with before you start adding splits to your app, I suggest you check out [Topeka on Github](https://github.com/googlesamples/android-topeka) which already includes image resources for many densities — perfect for trying out splits!

Open the app/build.gradle file and add the following lines in the android section:

build.gradle

		android {
		    ...
		    splits {
		        density {
		            enable true
		            exclude 'ldpi', 'tvdpi', 'xxxhdpi'
		//alternatively use the following two lines to only include:
		//            reset()
		//            include 'mdpi', 'hdpi', 'xhdpi', 'xxhdpi'
		            compatibleScreens 'small', 'normal', 'large', 'xlarge'
		        }
		    }
		}

The configuration options are pretty straightforward. First, you enable splitting by screen density, then you can exclude (or include) splits for certain configurations from being created and finally specify what screens your app is compatible with, which should usually be all four buckets — from small to extra large.

By default, a universal APK with all densities included will be created as well. It’s vital that you publish this APK on the Play Store with a lower version number than all other density-specific packages. This is necessary for 2 reasons:

1. The mechanism used to target specific devices is the <compatible-screens> section in the Manifest which is not future-proof. It requires listing every supported density explicitly and there are no catch-all buckets. When new devices come out, sometimes new screen densities are introduced (as it happened with the Nexus 5X and 6P) and these devices would not be able to download your app without the universal APK fallback.
2. Unfortunately, only named densities currently work with the include/exclude statements for now, so you can’t create an APK that targets 280/360/420/480/560 dpi devices. I’ve filed a bug for that here.


Update: I have figured out a way to fix the above mentioned problem (2) by adding missing densities to the generated AndroidManifest.xml using a Gradle script. It might not be elegant, but it does the job while support is missing from the Android Gradle plugin. In this example, 280dpi devices will get the xhdpi APK, 420/400/360 dpi devices will get xxhdpi etc.

build.gradle

		ext.additionalDensities = ['xhdpi': ['280'], 'xxhdpi': ['420', '400', '360'], 'xxxhdpi': ['560']]
		import com.android.build.OutputFile
		
		android.applicationVariants.all { variant ->
		    // assign different version code for each output
		    variant.outputs.each { output ->
		        if (output.getFilter(OutputFile.DENSITY) != null && project.ext.additionalDensities.containsKey(output.getFilter(OutputFile.DENSITY))) {
		            output.processManifest.doFirst {
		                def manifestFile = new File(project.buildDir, "intermediates" + File.separator + "manifests" + File.separator + "density" + File.separator + output.getFilter(OutputFile.DENSITY) + File.separator + variant.buildType.name + File.separator + "AndroidManifest.xml")
		                def manifestText = manifestFile.text
		                for (String density : project.ext.additionalDensities.get(output.getFilter(OutputFile.DENSITY))) {
		                    manifestText = manifestText.replaceAll("</compatible-screens>", "<screen android:screenSize=\"small\" android:screenDensity=\"${density}\" />\n" +
		                            "<screen android:screenSize=\"large\" android:screenDensity=\"${density}\" />\n" +
		                            "<screen android:screenSize=\"xlarge\" android:screenDensity=\"${density}\" />\n" +
		                            "<screen android:screenSize=\"normal\" android:screenDensity=\"${density}\" />\n </compatible-screens>")
		                }
		                manifestFile.text = manifestText
		            }
		        }
		    }
		}

You can inspect the Manifest entries that are created by the build system in intermediate files located in your project’s folder:

		/app/build/intermediates/manifests/density/hdpi/debug/AndroidManifest.xml

They’re partial Manifest files and contain only the <compatible-screens> part that gets merged with your main Manifest file:

		<?xml version="1.0" encoding="utf-8"?>
		<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="">
		 <compatible-screens>
		 <screen android:screenSize="small" android:screenDensity="hdpi" />
		 <screen android:screenSize="normal" android:screenDensity="hdpi" />
		 <screen android:screenSize="large" android:screenDensity="hdpi" />
		 <screen android:screenSize="xlarge" android:screenDensity="hdpi" />
		 </compatible-screens>
		</manifest>

This will be used by the Play Store to filter out devices that are not in the defined density bucket and to deliver the correct APK to a device which is requesting to install your app.

**Note:** if there are any images that you wish to always include in all available densities so that they are not stripped away in the split process, you should put them in the mipmap resource folder. This is normally used for the app icon, because some launchers may use an icon from a higher density bucket.

Savings for the Topeka app when splits are enabled are substantial. Here are the APK sizes:

		Original (universal) APK:   3.5 MB
		MDPI devices:               1.1 MB (2.4 MB savings)
		HDPI devices:               1.2 MB (2.3 MB savings)
		XHDPI devices:              1.3 MB (2.2 MB savings)

Of course this will vary from app to app depending on the size of image resources.

ABI splits
Similar to density based splits, you can also configure ABI splits for devices with different CPU architectures:

		splits {
		    abi {
		        enable true
		        reset()
		        include 'x86', 'armeabi-v7a', 'mips'
		        universalApk false
		    }
		}
You can control if you wish to build a universal APK but this shouldn’t normally be needed. Remember to give the x86_64 and x86 higher version numbers than ARM, as many x86 devices can run ARM code through an emulation layer, although with lower performance. By setting up the version numbering correctly you can make sure they get the optimal library.

**Update:** If you don’t wish to manage too many APKs (one for every ABI, potentially multiplied by the number of density splits), there is a way to leverage the universal APK. If you have any analytics data for your app, look at how many users are on which ABIs. Target the most popular ones (usually ARM and maybe x86) with a split APK and serve a universal APK to everyone else. That way you can make sure that > 90% of users get the optimal version, while others will still be able to download and use your app.

Of course, it would be best to serve every user the optimal version, but as with everything — you need to decide how much time you want to spend as a developer maintaining releases and how many users will benefit from the optimization.

### Setting version codes
Here’s a code snippet that will help you with setting different version codes for the output APKs so that you can upload them to Play Store as a single listing.

		// map for the version codes
		ext.versionCodes = ['mdpi':1, 'hdpi':2, 'xhdpi':3].withDefault {0}
		import com.android.build.OutputFile
		android.applicationVariants.all { variant ->
		// assign different version code for each output
		    variant.outputs.each { output ->
		        output.versionCodeOverride = project.ext.versionCodes.get(output.getFilter(OutputFile.DENSITY)) * 1000000 + android.defaultConfig.versionCode
		    }
		}

This example uses 3 density splits and the version numbering is calculated as density versionCode * 1000000 + app’s versionCode. So the version numbers will go like this:

		Universal:       1,      2,       3 ...
		MDPI:      1000001,1000002, 1000003 ...
		HDPI:      2000001,2000002, 2000003 ...
		XHDPI:     3000001,3000002, 3000003 ...
That way, only devices who don’t fit any density-specific bucket will get the Universal APK. You can use similar approach to set version codes for ABI splits, by changing OutputFile.DENSITY to OutputFile.ABI and using ABI names like ‘x86’ and ‘armeabi-v7a’ instead of ‘mdpi’, ‘hdpi’ and ‘xhdpi’ in the code.

---

##  Part 5: Multi-APK through product flavors
In the previous article, I explained how to create ABI and density based multi-APK by using the splits mechanism in Android Studio. There is another, more flexible way of creating a multi-APK configuration for your app and it’s through the use of product flavors. First, a quick refresher from the [documentation](http://developer.android.com/tools/building/configuring-gradle.html#workBuildVariants):

The build system uses product flavors to create different product versions of your app. Each product version of your app can have different features or device requirements.

That’s seems exactly like something we need for multi-APK! By making small changes to the Manifest and resources for different flavors, you can essentially get many versions (we call them build variants) of your app built from a single project.

It’s actually possible to recreate splits using flavors. We could create a flavor for each density bucket and use the [resConfigs](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.ProductFlavor.html#com.android.build.gradle.internal.dsl.ProductFlavor:resConfigs%28java.lang.String[]%29) option to specify which drawables should be retained for each flavor.

Note: resConfigs behavior has changed from Build Tools v21 onwards. You can only specify one density bucket and the AAPT tool will automatically figure out which drawables need to go into the APK. It is an error to specify more than 1 density bucket for a variant.

Build.gradle

		android {
		    ...
		    productFlavors {
		        xhdpi {
		            resConfigs "xhdpi"
		            versionCode 300001
		        }
		        hdpi {
		            resConfigs "hdpi"
		            versionCode 200001
		        }
		        mdpi {
		            resConfigs "mdpi"
		            versionCode 100001
		        }
		        anydpi {
		            versionCode 1
		        }
		    }
		}

Then, for each flavor create a new AndroidManifest.xml under app/src/[flavorname]/AndroidManifest.xml and fill it in with the correct screen filtering directives. Because we’re doing this manually, we can overcome the lack of support for numeric density buckets in splits. You might choose to combine them with the next higher bucket for example, like in this snippet (xhdpi is the name for 320 dpi screens):

app/src/xhdpi/AndroidManifest.xml

		<?xml version="1.0" encoding="utf-8"?>
		<manifest xmlns:android="http://schemas.android.com/apk/res/android">
		<compatible-screens>
		<screen android:screenSize="small" android:screenDensity="xhdpi” />
		<screen android:screenSize="normal" android:screenDensity="xhdpi" />
		<screen android:screenSize="large" android:screenDensity="xhdpi" />
		<screen android:screenSize="xlarge" android:screenDensity="xhdpi" />
		<screen android:screenSize="small" android:screenDensity="280" />
		<screen android:screenSize="normal" android:screenDensity="280" />
		<screen android:screenSize="large" android:screenDensity="280" />
		<screen android:screenSize="xlarge" android:screenDensity="280" /></compatible-screens>
		</manifest>
Remember to also build and publish a universal (anydpi flavor in the example above) APK with no extra Manifest entries and the lowest versionCode to support future devices.

### MinSdkVersion-based multi-APK
Many optimizations that I will talk about in the upcoming chapters of the #smallerAPK articles depend on new compression formats or vector images support that were only introduced in more recent Android versions. If we want to take advantage of those while still retaining compatibility with older devices, normally we’d have to include the same resources multiple times.
By using flavors, we can create multi-APK configurations that were not possible with splits. Let’s consider creating a separate version of the app targeting only more recent Android versions and one supporting older devices.

Build.gradle

		android {
		    productFlavors {
		        prelollipop {
		            versionCode 1
		        }
		        lollipop {
		            minSdkVersion 21
		            versionCode 2
		        }
		    }
		}

Now, by placing resources in app/src/prelollipop/res/ or app/src/lollipop/res you can control which files will be packaged with each release, so for example you can include your [VectorDrawables](https://medium.com/@wkalicinski/smallerapk-part-7-image-optimization-shape-and-vectordrawables-ed6be3dca3f#4cb7) only for Android 5.0+ builds and [PNG/WebP](https://medium.com/@wkalicinski/smallerapk-part-6-image-optimization-zopfli-webp-4c462955647d#2de9) for pre-Lollipop builds.

If you need product flavors along two or more dimensions, like screen density and minSdkVersion, this is how you would set it up:

Build.gradle

		android {
		    ...
		    flavorDimensions “density”, “version”
		    productFlavors {
		        xhdpi {
		            dimension "density"
		            resConfigs "xhdpi"
		            versionCode 4
		        }
		        //other densities here...
		        anydpi {
		            dimension "density"
		            versionCode 1
		        }
		        prelollipop {
		            dimension "version"
		            versionCode 1
		        }
		        lollipop {
		            dimension "version"
		            minSdkVersion 21
		            versionCode 2
		        }
		    }
		}
This makes it a bit more complicated to set the correct version number, as we need to compute it for each combined flavor. Always remember that the highest versioned APK that can be installed on the device (i.e. matches minSdkVersion and other filters) is always downloaded from the Play Store. You can find a handy script that you can adapt for your needs [here](http://tools.android.com/tech-docs/new-build-system/tips).

---
## Part 6: Image optimization, Zopfli & WebP
Every app is bound to include image resources at some point, even if it’s just a few icons. There’s two ways images can contribute to application size. Firstly, we package them in the APK as resources and assets. Secondly, apps download images from servers at runtime and usually keep a disk cache of those images for quicker access. 

Remember that any optimizations that I cover in this chapter can also be applied on the server side, saving you disk space on the device as well as network bandwidth.

First, a some basics. The two most popular compression formats you will use for images are JPEG and PNG. A quick reminder when to use which:

JPEG — photographs, backgrounds. No transparency support. Size and quality varies greatly with chosen compression level, so if you’re sticking with JPEG try and experiment with it to lower file size.

PNG — logos, graphs, icons, line art; basically anything with sharp edges and contrasts. Supports transparency. Images with large areas of contiguous color compress well, gradients and photographic imagery tend to produce bigger files.

### WebP
There’s another format that you might want to consider for your Android apps and that’s WebP (pronounced “weppy”). It tends to produce smaller (on average 30%) file sizes and is suitable for replacing both JPEG and PNG in your app, as it handles all kinds of image data.
There are some downsides of course. Lossy WebP support (suitable for replacing most JPEGs and some PNGs) is guaranteed on Android 4.0+ devices. Newer WebP features (transparency, lossless, suitable for PNGs) are supported since Android 4.2.1+.

**Note:** WebP images also take a little more CPU power to decompress at runtime, which might mean slightly longer load times.

**Note 2:** You cannot use WebP for app launcher icons.

### Zopfli-compressed PNGs
If you’re not prepared to adopt WebP just yet, there’s one more avenue you might want to explore when it comes to optimizing PNGs. The cruncher that is part of the Android build system already does some common optimizations like discarding metadata from images and converting color palettes to 8-bit when it can, but we can do better if we pre-optimize our PNGs with Zopfli.

Zopfli is a compression algorithm created by engineers at Google. It’s compatible with the popular DEFLATE specification used for compressing ZIP files and… you guessed it, the image data stream inside PNGs!

Zopfli compressed data can be read by a standard ZIP (or PNG) reader, so no changes will be required in code. You can use one of the several existing tools (AdvPNG, ZopfliPNG) that will help you zopflify your images before building (you only need to do it once for each image file).

Unfortunately there’s no automatic support for this optimization from Android tools at this time. Moreover, you will have to disable the built-in image cruncher by adding these lines to your build.gradle:

build.gradle

		android {
		    ...
		    aaptOptions {
		        cruncherEnabled = false
		    }
		}
This is needed because the AAPT tool doesn’t check if the file it produces is smaller than the source file, which might undo some of the space savings from zopfli optimized images.
Note: The cruncher will still process 9-patch images, as they require special handling at build time.

---
##  Part 7: Image optimization, Shape and VectorDrawables
Raster image formats like JPEG, PNG and WebP are great for some image types and sometimes even necessary, but they have two major drawbacks — their size and the fact that you need to keep them in your project in many versions for different screen densities, which compounds the problem even further. But some image types, especially icons and UI elements, can be easily recreated with a more concise representation, using XML and path information.

### Shape Drawable
Available in Android from the beginning and usable regardless of platform version, this is a type of generic drawable defined in an XML file. It can only support very basic shapes, like rectangles, ovals, lines and rings, but sometimes it’s enough for simple backgrounds or decorations. Through its attributes you can also create gradients, rounded corners and outline stroke effects.

A thorough guide to shape drawables is here. You can use them whenever you would use a bitmap or other types of drawables in your layouts, e.g. in android:background or android:src.

### VectorDrawables
Since API level 21 (Lollipop), Android supports a new type of drawable for representing vector graphics (perfect for icons!), called [VectorDrawable](http://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html).

VectorDrawables are density independent (one file will work for all screens), retain full quality when scaled and they are usually very small in size. Using VectorDrawables can have a dramatic impact for slimming down your APK.

The format is similar to SVG in that it uses the same path format, but VectorDrawables have their own XML schema. That means SVGs need to be converted before you can use them, and moreover not all SVG features are supported. You can use the Vector Asset Studio within Android Studio for the conversion.

Our Gradle Android plugin can also help if you’d like to keep your app backwards compatible. Add the following lines to your build to choose densities for which PNGs will be generated from VectorDrawables found in the drawable/ folder:

build.gradle

		android {
		    ...
		    defaultConfig {
		        //if you're using Android Gradle plugin < 2.0.0
		        //omit the vectorDrawables block
		        vectorDrawables {
		            generatedDensities = ["mdpi", "hdpi", "xhdpi"]
		        }
		    }
		}

**Note:** If you don’t wish to generate PNGs, just set generatedDensities to an empty list: generatedDensities = [].

You can put the vectorDrawables block inside product flavor definitions if you’re using Multi-APK to only generate images for pre-lollipop builds.

### VectorDrawableCompat
AppCompat version 23.2 now includes a backwards compatible implementation of VectorDrawables. Using this approach, with minimal changes to your layouts and code, you can forgo including generated PNGs in all versions of your app (on API 7+).

Chris Banes explains [how to use VectorDrawableCompat in his post](https://medium.com/@chrisbanes/appcompat-v23-2-age-of-the-vectors-91cbafa87c88) or you can check out this and other features in the new Support Library [here](http://android-developers.blogspot.co.uk/2016/02/android-support-library-232.html).

---

## Part 8: Native libraries, open from APK.

Adding even a single native library can contribute quite significantly to your app’s size. If your app uses any native libraries (i.e. there are .so files in your APK), this article is for you.

There are various techniques and flags for C/C++ compilation that can make your .so files smaller, but I will not be discussing native builds in this article as it’s a broad and very advanced topic, with each particular case requiring special treatment. Besides, it might happen that you get compiled .so files only and without access to the source code there’s not much you can do about their size. Instead, I will show you this one weird trick that cuts disk space usage in half! No, really… read on :)

In Part 1 of this series, I mentioned that the biggest waste of space from having native libraries comes from the fact that compressed .so files are copied out from the APK at install time into a user’s /data partition. The originals are never deleted from the APK (because we can’t delete files from signed APKs, remember?). Thus, they take up twice the amount of space on the device.

Starting with Android 6.0 (Marshmallow), there is a new flag that you can set on your 
<application>:

AndroidManifest.xml

		<application
		   android:extractNativeLibs=”false”
		   ...
		>
This will essentially prevent the system from creating a second copy of the .so files and fix the System.loadLibrary call so it’s able to find and open native libs straight from the APK, no code changes on your part required.

There are some important preconditions for that to work though and that’s where things get more complicated:

1. The .so files inside the APK cannot be compressed — they must be stored.
2. The .so files must be page aligned using zipalign -p 4


**Update: The part below is only valid for Android Studio version 2.1 and lower. Starting from Android Studio 2.2 Preview 2 and newest build tools, the build process will automatically store native libraries uncompressed and page aligned in the APK.**

Unfortunately, [there is no way currently](https://code.google.com/p/android/issues/detail?id=172630) (in AS 2.1 and below) to have this done automatically as part of the build. You will have to do it manually or write custom scripts, but regardless of how you wish to proceed, the recipe for success is more or less as follows:

1. Delete the .so files from the APK archive
2. Add the .so files back to the archive, with the ZIP compression level set to 0 (zero, sometimes also named STORE). 
Remember that you have to add the libraries on the same paths inside the archive as they were before.
3. Run zipalign -p 4 <APK file>

If you’re on Linux, you can use a script similar to this one:

fix_native_libs.sh

		FILENAME=$(basename "$1" .apk)
		OUT_FILENAME=${FILENAME}-noextract.apk
		OUT_FILENAME2=${FILENAME}-noextract-aligned.apk
		unzip "$1" "lib/*.so"
		cp "$1" $OUT_FILENAME
		zip -n ".so" -r $OUT_FILENAME lib
		zipalign -p 4 $OUT_FILENAME $OUT_FILENAME2
		rm $OUT_FILENAME

Let’s look at what effect on file and download sizes keeping native libraries uncompressed has:

### Initial download size
Should be roughly the same. How is that possible? The Play Store actually uses its own compression when sending APK files to users’ devices. Depending on the compressibility of your particular library, the download size might be roughly the same or just slightly larger.

### Update size
Should be smaller. Play Store uses a mechanism called “delta updates” to deliver new versions of apps to existing users. It calculates the difference between the new APK and the APK that’s installed on a device and only sends the binary difference needed to reconstruct the final APK on the device.

Having the native libraries uncompressed actually helps the algorithms used by Play calculate a more optimal (i.e. smaller) delta. These delta patch files will additionally be compressed for delivery.

### On-device size
Total size on-device will be smaller on Marshmallow and above. However, older Android versions will not recognize the android:extractNativeLibs flag and always copy out the .so files. The amount of additional space wasted because of using this technique is the difference between a compressed and uncompressed .so file.